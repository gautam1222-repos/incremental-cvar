# -*- coding: utf-8 -*-
"""inc_var(rqmc).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SFgcvwHbx_flbHOJNtqV3tdqZSPYfJOT

# INCREMENT VaR: Setting parameters
"""

import numpy as np

file1 = open('inc_params1.txt', 'r')
Lines = file1.readlines()

inc_var_params1 = []

for line in Lines:
    param = np.array([float(line[:-1].split(" ")[0]), float(line[:-1].split(" ")[1])])
    inc_var_params1.append(param)

print(inc_var_params1)

len(inc_var_params1)

import numpy as np

file1 = open('inc_params2.txt', 'r')
Lines = file1.readlines()

inc_var_params2 = []

for line in Lines:
    param = np.array([float(line[:-1].split(" ")[0]), float(line[:-1].split(" ")[1])])
    inc_var_params2.append(param)

print(inc_var_params2)

len(inc_var_params2)

import numpy as np

file1 = open('inc_params3.txt', 'r')
Lines = file1.readlines()

inc_var_params3 = []

for line in Lines:
    param = np.array([float(line[:-1].split(" ")[0]), float(line[:-1].split(" ")[1])])
    inc_var_params3.append(param)

print(inc_var_params3)

len(inc_var_params3)

inc_var_params2 = np.array(inc_var_params2)

inc_var_params1 = np.array(inc_var_params2)

print(inc_var_params1+inc_var_params2)

import numpy as np

file1 = open('inc_params4.txt', 'r')
Lines = file1.readlines()

inc_var_params4 = []

for line in Lines:
    param = np.array([float(line[:-1].split(" ")[0]), float(line[:-1].split(" ")[1])])
    inc_var_params4.append(param)

print(inc_var_params4)

len(inc_var_params4)

PARAMS = (inc_var_params1+inc_var_params2+inc_var_params3+inc_var_params4)/4

print(PARAMS)

import numpy as np

file1 = open('inc_params5.txt', 'r')
Lines = file1.readlines()

inc_var_params5 = []

for line in Lines:
    param = np.array([float(line[:-1].split(" ")[0]), float(line[:-1].split(" ")[1])])
    inc_var_params5.append(param)

print(inc_var_params5)

inc_var_params5

"""## INCREMENT VaR ONLY : Running Batch code module """

import numpy as np
import math
from scipy.stats import truncnorm

def gen_trunc_gauss_samples(mu, sd, a, b, N):
    a = (a-mu)/sd
    b = (b-mu)/sd
    samples = truncnorm.rvs(a, b, loc=mu, scale=sd, size = N)
    # samples = np.array([])
    # while(len(samples)<N):
    #     val = np.random.normal(loc=mu, scale=sd)
    #     if(val>=a and val <=b):
    #         samples = np.append(samples, val)
    return samples


def log_pdf_wrt_mu(x, mu, sd, a, b):
    
    expr1 = (x-mu)
    expr1/= sd**2

    # expr2_Nr = np.exp(-0.5*( (a-mu)/sd )**2) - np.exp(-0.5*( (b-mu)/sd )**2)
    # expr2_Dr = math.erf( (b-mu)/(np.sqrt(2)*sd) ) - math.erf( (a-mu)/(np.sqrt(2)*sd) )
    # expr2 = expr2_Nr/(2*np.sqrt(2)*expr2_Dr)

    # expr = expr1 + expr2
    
    return expr1

def log_pdf_wrt_sd(x, mu, sd, a, b):
    
    expr1 = (x-mu)**2 - sd**2
    expr1 /= sd**3

    # expr2_Nr = (a-mu)*np.exp(-0.5*(a-mu)**2/sd**2) - (b-mu)*np.exp(-0.5*(b-mu)**2/sd**2)
    # expr2_Dr = math.erf( (b-mu)/(np.sqrt(2)*sd) ) - math.erf( (a-mu)/(np.sqrt(2)*sd) )
    # expr2 = expr2_Nr/( 2*np.sqrt(2)*sd**2 )

    # expr = expr1+expr2

    return expr1

def Reward(samples):
    # sample_matrix = np.array(samples)
    axes = len(samples[0])
    N = len(samples)
    sum = np.zeros(N)
    # print(samples[:,0]+sum)
    for i in range(axes):
        sum = sum + samples[:,i]
    
    expr = 10/( 1+np.exp(-1*np.abs(sum-6)))
    return expr



def CVaRSGD(params, params2, d_params, proj_radius, center, t, eta):
    
    # params2 += eta*d_params
    # params += (1/(t+10))*(params2-params)
    params += eta*d_params
    if(np.linalg.norm(params-center)>proj_radius):
        print('projection')
        norm_val = np.linalg.norm(params-center)
        vec = params-center
        vec /= norm_val
        params = center + proj_radius*vec
    
    return params



'''
        |                          |                       |
        |        SAMPLE MATRIX     |       COORDINATES     |
 ====== | ======================== |=======================|
    i   |    X       Y       Z     |   X   |    Y  |    Z  |
        |    0       1       2     |       |       |       |
 ------ | ------------------------ |-------|-------|-------|
    0   |    x0      y0      z0    |   x0  |       |       |
    1   |    x1      y1      z1    |   x1  |       |       |
    2   |    x2      y2      z2    |   x2  |       |       |
    3   |    x3      y3      z3    |   x3  |       |       |
    4   |    x4      y4      z4    |   x4  |       |       |
    5   |    x5      y5      z5    |   x5  |       |       |
    6   |    x6      y6      z6    |   x6  |       |       |
    7   |    x7      y7      z7    |   x7  |       |       |
    8   |    x8      y8      z8    |   x8  |       |       |
    9   |    x9      y9      z9    |   x9  |       |       |
        |  [9][0]                  |   [9] |       |       |


    Now x6 = X[6], sample_matrix"[row=6][axis=0]"

'''

# grad = GCVAR(alpha, N, log_pdf_wrt_mu, samples, lower_limits, upper_limits, params, variances, rewards, VaR)
def GCVAR(alpha, N, log_pdf_wrt_mu, samples , lower_limits, upper_limits, params, variances, rewards, VaR):
    sample_matrix = np.array(samples)
    axes = len(sample_matrix[0])
    gcvar = np.zeros(axes)
    for i in range(len(rewards)):
        if(rewards[i]<=VaR):
            print('i',end='')
            for j in range(axes): 
                # each row = sample, each column = coordinate
                gcvar[j] += log_pdf_wrt_mu(sample_matrix[i][j], params[j], variances[j], lower_limits[j], upper_limits[j])*(rewards[i]-VaR)
            # # param[0] => mu_x, param[1] => sd_x
            # gcvar[0] += (log_pdf_wrt_mu(x[i], params[0], sd_x, a_x, b_x))*(rewards[i]-VaR)
            # # gcvar[1] += (log_pdf_wrt_sd(x[i], params[0], params[1], a_x, b_x))*(rewards[i]-VaR)
            # # param[2] => mu_y, param[3] =>sd_y
            # gcvar[1] += (log_pdf_wrt_mu(y[i], params[1], sd_y, a_y, b_y))*(rewards[i]-VaR)
            # # gcvar[3] += (log_pdf_wrt_sd(y[i], params[2], params[3], a_y, b_y))*(rewards[i]-VaR)    
    gcvar /= (alpha*N)
    print()
    return gcvar


def fun(alpha, mu_x, sd_x, a_x, b_x, mu_y, sd_y, a_y, b_y):
    N = 4000+np.random.randint(1000)%1000
    
    # generate samples
    x = gen_trunc_gauss_samples(mu_x, sd_x, a_x, b_y, N)
    y = gen_trunc_gauss_samples(mu_y, sd_y, a_y, b_y, N)
    
    # assign rewards
    rewards = Reward(x,y)
    print(rewards)
    # break
    # Calculate Value at Risk
    sort_rew = np.sort(rewards)
    VaR = sort_rew[int(alpha*N)]
    
    print ( np.mean(sort_rew[:int(alpha*N)+1]))

def list_of_pair_to_list_of_vector(pairs):
    vectors = []
    for pair in pairs:
        vectors.append(pair.reshape((-1, 1)))
    return vectors

def cvar_optimization_results(n_samples, means, variances, lower_limits, upper_limits, alpha=0.01, proj_radius=1000, lr=1e-3, epochs = 30000, digital_nets_enabled = False, enable_var_increment=False):
    
    # import inverse_transform_sampling
    # import digital_nets
    from scipy.stats import qmc

    N = n_samples
    n = int(np.log2(N))
    params = means.copy()
    n_params = len(params)
    params2 = np.zeros(n_params)

    axes = n_params
    center = np.zeros(axes)
    proj_radius = 1000
    
    norm_grad = np.array([])
    v = 0
    rho = 0.1
    
    for i in range(epochs):

        samples_axes = []
        samples = np.array([])
        
        if digital_nets_enabled:
            print('Using Digital Nets..')
            # uniform_point_set = digital_nets.generate_digital_nets_base2(n)
            # uniform_samples = []
            # np_uniform_samples = None
            # for point in uniform_point_set:
            #     pair = np.zeros(axes)
            #     for j in range(axes):
            #         pair[j] = point[j].item()
            #     uniform_samples.append(pair)
            #     np_uniform_samples = np.array(uniform_samples)
            # print('================')
            # print(np_uniform_samples)
            # print('================')
            
            sampler = qmc.Sobol(d=2, scramble=True)
            np_uniform_samples = sampler.random_base2(m=9)
            
            trunc_gauss_samples = np.zeros(np_uniform_samples.shape)
            for j in range(axes):
                trunc_gauss_samples[:,j] = inverse_transform_sampling.transform_to_trunc_normal(np_uniform_samples[:,j], lower_limits[j], upper_limits[j], params[j], variances[j])

            print(trunc_gauss_samples.shape)
            samples = trunc_gauss_samples
            # print(uniform_point_set[0])#00,10
            # print(uniform_point_set[0] [0].item())
            # print(uniform_point_set[0] [1][0])
            
            
            
        else:
            print('Not Using Digital Nets..')
            sample_axes = []
            for j in range(n_params):
                samples_axes.append( gen_trunc_gauss_samples(params[j], variances[j], lower_limits[j], upper_limits[j], N) )
            samples_transpose = np.array(samples_axes)
            samples = samples_transpose.T
        
        print('samples.shape = ',samples.shape)
        

        rewards = Reward(samples)

        # VaR = None
        # if enable_var_increment:
        #     VaR = var_increment(alpha, rewards, v, rho, i)
        #     print('VaR = ', VaR)
        # else:
        sort_rew = np.sort(rewards)
        VaR = sort_rew[int(alpha*N)]
        print('VaR = ', VaR)

        grad = GCVAR(alpha, N, log_pdf_wrt_mu, samples, lower_limits, upper_limits, params, variances, rewards, VaR)
        print('grad = ', grad)
        
        norm_grad = np.append(norm_grad, np.linalg.norm(grad))
        params = CVaRSGD(params, params2, grad, proj_radius, center, i+1, lr)
        print('params = ', params)
        # break
        if (i+1)%1==0:
            break
            # if (i+1)%500==0:
                # import matplotlib.pyplot as plt
                # plt.plot(norm_grad)
            # print('############# ITERATION ######', i+1)
            print()
            print()
    
    return norm_grad

axes = 2
n_samples = 4096

variances = np.array([0.5, 0.5])
lower_limits = np.array([-4.0, -3.0])
upper_limits = np.array([4.0, 3.0])

inc_var_norms = []

cnt_idx = 0

for mean in PARAMS:
    print('############ ITERATION : ', cnt_idx, '###################')
    inc_var_norms.append(cvar_optimization_results(n_samples, mean, variances, lower_limits, upper_limits, digital_nets_enabled=False))
    cnt_idx += 1

import matplotlib.pyplot as plt
plt.plot(inc_var_norms[:500])
# 500 * 300

import matplotlib.pyplot as plt
plt.plot(inc_var_norms)

"""# """



"""# INCREMENT VaR with RQMC: """



import numpy as np

file1 = open('inc_rqmc_params1.txt', 'r')
Lines = file1.readlines()

inc_var_rqmc_params1 = []

for line in Lines:
    param = np.array([float(line[:-1].split(" ")[0]), float(line[:-1].split(" ")[1])])
    inc_var_rqmc_params1.append(param)

print(inc_var_rqmc_params1)

len(inc_var_rqmc_params1)

import numpy as np

file1 = open('inc_rqmc_params2.txt', 'r')
Lines = file1.readlines()

inc_var_rqmc_params2 = []

for line in Lines:
    param = np.array([float(line[:-1].split(" ")[0]), float(line[:-1].split(" ")[1])])
    inc_var_rqmc_params2.append(param)

print(inc_var_rqmc_params2)

len(inc_var_rqmc_params2)

import numpy as np

file1 = open('inc_rqmc_params3.txt', 'r')
Lines = file1.readlines()

inc_var_rqmc_params3 = []

for line in Lines:
    param = np.array([float(line[:-1].split(" ")[0]), float(line[:-1].split(" ")[1])])
    inc_var_rqmc_params3.append(param)

print(inc_var_rqmc_params3)

len(inc_var_rqmc_params3)

inc_var_rqmc_params2 = np.array(inc_var_rqmc_params2)

inc_var_rqmc_params1 = np.array(inc_var_rqmc_params2)

print(inc_var_rqmc_params1+inc_var_rqmc_params2)

import numpy as np

file1 = open('inc_rqmc_params4.txt', 'r')
Lines = file1.readlines()

inc_var_rqmc_params4 = []

for line in Lines:
    param = np.array([float(line[:-1].split(" ")[0]), float(line[:-1].split(" ")[1])])
    inc_var_rqmc_params4.append(param)

print(inc_var_rqmc_params4)

len(inc_var_rqmc_params4)

PARAMS_RQMC = (inc_var_rqmc_params1+inc_var_rqmc_params2+inc_var_rqmc_params3+inc_var_rqmc_params4)/4

print(PARAMS_RQMC)

import numpy as np

file1 = open('inc_rqmc_params5 9e-1 9e-2 4e-2.txt', 'r')
Lines = file1.readlines()

inc_var_rqmc_params5 = []

for line in Lines:
    param = np.array([float(line[:-1].split(" ")[0]), float(line[:-1].split(" ")[1])])
    inc_var_rqmc_params5.append(param)

print(inc_var_rqmc_params5)

axes = 2
n_samples = 4096

variances = np.array([0.5, 0.5])
lower_limits = np.array([-4.0, -3.0])
upper_limits = np.array([4.0, 3.0])

inc_var_rqmc_norms = []

cnt_idx = 0

for mean in inc_var_rqmc_params5:
    print('############ ITERATION : ', cnt_idx, '###################')
    inc_var_rqmc_norms.append(cvar_optimization_results(n_samples, mean, variances, lower_limits, upper_limits, digital_nets_enabled=False))
    cnt_idx += 1

import matplotlib.pyplot as plt

plt.plot(inc_var_rqmc_norms)

plt.plot(inc_var_rqmc_norms[:500])

plt.plot(inc_var_norms[:300], color='b')
plt.plot(inc_var_rqmc_norms[:300], color='g')
plt.show()

import matplotlib.pyplot as plt

plt.plot(inc_var_norms[:300], label='IncVar')
plt.plot(inc_var_rqmc_norms[:300], color='g', label='IncVar+RQMC')
plt.xlabel('each 500 iterations')
plt.ylabel('Norm of the GCVaR')
plt.show()

